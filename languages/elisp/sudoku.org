#+title: sudoku solver

Design Notes:
- The board (a list of lists of integers) is the fundamental datatype.

#+begin_src emacs-lisp
(load-file "~/repos/cora/src/cora.el")
#+end_src

#+begin_src emacs-lisp
(setq board '((0 0 1  8 0 0  0 0 0)
              (6 7 0  2 0 3  0 1 0)
              (2 0 5  7 0 0  6 0 3)

              (3 5 0  6 2 0  8 0 0)
              (7 6 2  0 5 8  3 0 0)
              (0 0 0  0 0 4  0 5 0)

              (0 9 0  5 8 6  0 0 0)
              (5 0 0  9 0 0  7 0 0)
              (0 2 6  4 3 0  5 9 0)))
#+end_src

#+begin_src emacs-lisp
; indexing into board
(list-ref board 3 6) ; 8
(list-ref board 1 1) ; 7
#+end_src

#+begin_src emacs-lis
#+begin_src emacs-lisp
(defun get-cell (row col)
  (let ((a (/ row 3))
        (b (/ col 3)))
    (cond ((= 0 a) (cond ((= 0 b) 0)
                         ((= 1 b) 1)
                         ((= 2 b) 2)))
          ((= 1 a) (cond ((= 0 b) 3)
                         ((= 1 b) 4)
                         ((= 2 b) 5)))
          ((= 2 a) (cond ((= 0 b) 6)
                         ((= 1 b) 7)
                         ((= 2 b) 8))))))
#+end_src

#+begin_src emacs-lisp
;; read-col-values :: [[integer]] -> [integers]
(defun read-col-values (board col)
  "Return the set of values assigned to the column (COL) on the BOARD."
  (let ((values (foldl
                  (lambda (outer-acc row)
                    (foldl
                      (lambda (inner-acc pair)
                        (if (= col (car pair)) ; if column
                          (cons (cdr pair) inner-acc)
                          inner-acc))
                      outer-acc
                      (enumerate row)))
                  '()
                  board)))
    (remove-duplicates values)))


;; read-row-values :: [[integer]] -> [integers]
(defun read-row-values (board row)
  "Return the set of values assigned to the ROW on the BOARD."
  (let ((values (list-ref board row)))
    (remove-duplicates values)))


;; read-cell-values :: [[integer]] -> [integers]
(defun read-cell-values (board cell)
  "Return the set of values assigned to the CELL on the BOARD."
  (let ((values (TODO)))
    (remove-duplicates values)))
#+end_src

#+begin_src emacs-lisp
(defun possible? (board row col value)
  "Predicate. Is it possible to enter the given VALUE in at this position (ROW
and COL) on the BOARD?"
  (not (member value (remove-duplicates (append (read-col-values (board col))
                                                (read-row-values (board row))
                                                (read-cell-values (board (get-cell row col))))))))

(possible? board 0 0 1) ; TODO test
#+end_src

#+begin_src emacs-lisp
(defun set-ref (board row col value)
  TODO)
#+end_src

#+begin_src emacs-lisp
(defun for ((var lst))
  TODO)
#+end_src

#+begin_src emacs-lisp
;; solve :: [[integer]] -> [[integer]]
;;
;; Strategy: Iterate over the board and check for what's possible, then enter
;; possiblity and continue. Backtrack when no option is possible.
(defun solve (board)
  "Solve Sudoku BOARD."
  (for ((col (range 9))
        (row (range 9))
        (n (range 1 (inc 9))))
    (when (and (= 0 (list-ref board row col))
               (possible? board row col n))
      ; set value to n and solve if solve returns, continue
      (solve (set-ref board row col n)))))

(solve board)
#+end_src

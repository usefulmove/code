---
title: "COVID-19 Risk Modeling"
author: ""
output:
  html_document:
    css: custom.css
---

`r format(Sys.time(), '%B %d, %Y')`

![](./covid.png)

<style>
body {text-align: justify}
</style>

<br>

# Background

## Open Access Coronavirus Disease Epidemiological Data

### Johns Hopkins University

The Center for Systems Science and Engineering (CSSE) at Johns Hopkins University provides a public, global COVID-19 Github repository (https://github.com/CSSEGISandData/COVID-19) with anonymous patient data aggregated from a number of sources.

>We have built a centralised repository of individual-level information on patients with laboratory-confirmed COVID-19 (in China, confirmed by detection of virus nucleic acid at the City and Provincial Centers for Disease Control and Prevention), including their travel history, location (highest resolution available and corresponding latitude and longitude), symptoms, and reported onset dates, as well as confirmation dates and basic demographics. Information is collated from a variety of sources, including official reports from WHO, Ministries of Health, and Chinese local, provincial, and national health authorities. If additional data are available from reliable online reports, they are included. Data are available openly and are updated on a regular basis (around twice a day).

CSSE Data Sources (partial list):

- World Health Organization (WHO): https://www.who.int
- European Centre for Disease Prevention and Control (ECDC): https://www.ecdc.europa.eu/en/geographical-distribution-2019-ncov-cases
- US CDC: https://www.cdc.gov/coronavirus/2019-ncov/index.html
- DXY.cn. Pneumonia. 2020. http://3g.dxy.cn/newh5/view/pneumonia
- BNO News: https://bnonews.com/index.php/2020/02/the-latest-coronavirus-cases
- WorldoMeters: https://www.worldometers.info/coronavirus
- 1Point3Arces: https://coronavirus.1point3acres.com/en
- COVID Tracking Project: https://covidtracking.com/data

The CSSE data are used for all global analyses in this document.

### The New York Times

The New York Times has also provided public human coronavirus disease case and death data for the United States by county and by state. The U.S. data used for this analysis are pulled directly from The New York Times COVID-19 Github repository (https://github.com/nytimes/covid-19-data).

>The New York Times is releasing a series of data files with cumulative counts of coronavirus cases in the United States, at the state and county level, over time. We are compiling this time series data from state and local governments and health departments in an attempt to provide a complete record of the ongoing outbreak.
>
>Since late January, The Times has tracked cases of coronavirus in real time as they were identified after testing. Because of the widespread shortage of testing, however, the data is necessarily limited in the picture it presents of the outbreak.
>
>We have used this data to power our maps and reporting tracking the outbreak, and it is now being made available to the public in response to requests from researchers, scientists and government officials who would like access to the data to better understand the outbreak.
>
>The data begins with the first reported coronavirus case in Washington State on Jan. 21, 2020. We will publish regular updates to the data in this repository.

### Our World in Data

Hospital and ICU data collected from a number of official sources has been collated and maintained by Our World in Data. The the collated data and a complete list of country-by-country sources is available on GitHub (https://github.com/owid/covid-19-data).

<br>

## Data Analysis

The COVID-19 data from both the John Hopkins and New York Times repositories are pulled and used to calculate the rate of new reported cases for each country and the rates of new reported cases and deaths for each U.S. state and county. These rates are used to generate a predictive regression model for each locale. A risk prediction (ρ) is generated from these models, and the countries, states, and counties with the highest predicted risk are compared in the charts in this document. In the U.S. case-death charts, a generalized additive model (GAM) smoothing function is fit to each data set to make it easier to visualize trends.

The risk assessment methodology used in this analysis has not been fully validated and is affected by noise in the data. There is a phenomenon that has been reported in White House press briefings in which some counties report updates on Mondays for the incremental changes over the weekend. Cyclical weekly variation can be observed in the data. This limits the accuracy of the model predictions. To increase prediction robustness, the model has been tuned to use data over a multi-day period as a compromise between the speed of the detection of a relevant changes in risk predictions and prediction error caused by sensitivity to noise.

The predictive analytics model is built with the open-source [R programming language](https://en.wikipedia.org/wiki/R_(programming_language)) using the [Tidyverse](https://www.tidyverse.org/) family of packages.

```{r setup, include = FALSE}

knitr::opts_chunk$set(
  echo = FALSE,
  out.width = "100%",
  fig.asp = 0.8,
  fig.align = "center",
  message = FALSE,
  warning = FALSE
)

library(tidyverse)
library(ggthemes)
library(grid)
library(gridExtra)
library(lubridate)
library(RColorBrewer)
library(magrittr)
library(ggsci)
library(zoo)
library(DBI)
#library(RSQLite)
#library(RMySQL)
library(RMariaDB)
library(ggrepel)

## read in supporting personal library files
source("../library/ded/ded.R")
regions <- readr::read_csv("../library/regions.csv")
eu_countries <- read_csv("../library/eu-countries.csv")
gdp <- readr::read_csv("../library/gdp-ppp-per-capita.csv")  # per capita GDP (PPP) in international dollars

#library_db <- dbConnect(SQLite(), "~/repos/code/library.db") 

library_db <- dbConnect(
  MariaDB(),
  #MySQL(),
  dbname = "b28kw3czffvrcmddjxri",
  host = "b28kw3czffvrcmddjxri-mysql.services.clever-cloud.com",
  port = 3306,
  user = "uregdz06i7ou4d65",
  password = "q6sGFI1tu1fsAvIPVFQh"
)
  
#dbListTables(library_db)
state_populations_2018 <- dbGetQuery(
  # submit SQL query to library database for state population and region data
  library_db,
  "
    SELECT
      p.state,
      p.year,
      p.population,
      s.Region AS region
    FROM
      population_us_states_2010_2018 p LEFT JOIN us_states s
      ON p.state LIKE s.State
    WHERE year LIKE '2018'
    ;
  "
)
dbDisconnect(library_db)

## ggplot defaults
prim_color <- pal_jco()(10)[1]
alt_color <- pal_jco()(10)[5]

theme_set(theme_minimal())

```

```{r csse_tidy}

# import data
global_cases <- read_csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv")

global_deaths <- read_csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv")

# tidy data
#
#   data comes in an untidy format with date columns containing the cumulative number of case or death entries

global_cases <- global_cases %>%
  pivot_longer(
    cols = 5:ncol(global_cases),
    names_to = "date",
    values_to = "cases"
  ) %>%
  rename(
    province = `Province/State`,
    country = `Country/Region`,
    latitude = Lat,
    longitude = Long
  ) %>%
  mutate(
    date = lubridate::mdy(date)
  )

eu_cases <- global_cases %>%
  filter(country %in% c(eu_countries$Country, "Czechia"))

eu_combined_cases <- eu_cases %>%
  group_by(date) %>%
  summarise(cases = sum(cases)) %>%
  mutate(
    ncases = cases - lag(cases, default = cases[1])
  )

```

```{r nytimes_tidy, include = FALSE}

#data_path <- "../../covid-19-data/"
data_path <- "https://raw.githubusercontent.com/nytimes/covid-19-data/master/"

# united states
us <- read_csv(str_glue("{data_path}us.csv"))
us_live <- read_csv(str_glue("{data_path}live/us.csv"))

# states
state_df <- read_csv(str_glue("{data_path}us-states.csv"))

# counties
county_df <- read_csv(str_glue("{data_path}us-counties.csv"))

```

```{r owid_tidy, include = FALSE}

hospitalizations_raw <- read_csv("https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/hospitalizations/covid-hospitalizations.csv")

#convert to a tidier format
hosps <- hospitalizations_raw %>% 
  pivot_wider(
    names_from = indicator,
    values_from = value
  )

```

```{r mask_use_tidy, include = FALSE}

mask_data_path <- "../../covid-19-data/mask-use/mask-use-by-county.csv"

# mask use
mask_use_estimates <- read_csv(mask_data_path)

distinct_counties <- county_df %>%
  distinct(fips, county, state)

mask_use_estimates <- mask_use_estimates %>%
  left_join(distinct_counties, by = c("COUNTYFP" = "fips")) %>%
  filter(!is.na(county))

```

```{r utensils, include = FALSE}

# data analysis functions

get_country <- function(country_name) {
  c <- global_cases %>%
    filter(country == country_name)  # country object

  c <- c %>%
    mutate(
      ncases = cases - lag(cases, default = cases[1])
    )

  c
}

get_state <- function(state_name) {
  s <- state_df[state_df$state == state_name, ] # state object

  s <- s %>%
    mutate(
      ncases = cases - lag(cases, default = cases[1]),
      ndeaths = deaths - lag(deaths, default = deaths[1])
    )

  s
}

get_cnty <- function(cnty_name, state_name) {
  c <- county_df %>%
    filter(county == cnty_name, state == state_name) # county object

  if (nrow(c) > 1) {
    c <- c %>%
      mutate(
        ncases = cases - lag(cases, default = cases[1]),
        ndeaths = deaths - lag(deaths, default = deaths[1])
      )
  }

  c
}

covid <- function(state_name = "United States", time_frame = "all") {
  if (state_name == "United States") {
    s <- us
  }
  else {
    s <- get_state(state_name)
  }
  
  if (time_frame == "all") {
    x_origin <- "2020-03-01"
  }
  else {
    x_origin <- time_frame
  }

  # output stats
  print(str_glue("{state_name} has {format(s$cases[nrow(s)], big.mark = ',')} cases ",
                 "({format(s$ncases[nrow(s)], big.mark = ',')} cases per day) and ",
                 "{format(s$deaths[nrow(s)], big.mark = ',')} deaths ",
                 "({format(s$ndeaths[nrow(s)], big.mark = ',')} deaths per day)."
        )
  )

  # display new cases and new deaths
  scale_d <- 20

  p <- ggplot(data = s, mapping = aes(x = date)) +
    #geom_point(
    #  aes(y = ndeaths * scale_d, color = prim_color),  # unclear why color reversal is required
    #  size = 0.6, na.rm = TRUE, alpha = 0.8
    #) +
    #geom_point(
    #  aes(y = ncases, color = "#808080"),  # unclear why color reversal is required
    #  size = 0.6, na.rm = TRUE, alpha = 0.8
    #) +
    #geom_smooth(
    #  aes(y = ndeaths * scale_d),
    #  se = FALSE,
    #  color = "#808080",
    #  method = "gam", formula = y ~ s(x, bs = "cs"), level = 0.9,
    #  na.rm = TRUE
    #) +
    #geom_smooth(
    #  aes(y = ncases),
    #  se = FALSE,
    #  color = "black",
    #  method = "gam", formula = y ~ s(x, bs = "cs"), level = 0.9,
    #  na.rm = TRUE
    #) +
    geom_line(
      aes(
        y = rollmean(
              ndeaths * scale_d,
              k = 7,
              fill = NA
            )
      ),
      color = "08080",
      size = 1,
      na.rm = TRUE
    ) +
    geom_line(
      aes(
        y = rollmean(
              ncases,
              k = 7,
              fill = NA
            )
      ),
      color = prim_color,
      size = 1,
      na.rm = TRUE
    ) +
    labs(
      subtitle = state_name,
      x = "",
      y = "cases",
      color = "",
      caption = "(seven-day average)"
    ) +
    scale_y_continuous(
      labels = scales::comma,
      sec.axis = sec_axis(~ . / scale_d,
                          name = "deaths",
                          labels = scales::comma
                 )
    ) +
    coord_cartesian(xlim = as.Date(c(x_origin,
                                     Sys.Date()
                                     ),
                                   origin = "1960-10-01"
                           )
    ) +
    scale_color_manual(
      labels = c("deaths", "cases"),
      values = c("#808080", prim_color),
      guide = "none"
    ) +
    theme(
      axis.title.y = element_text(color = prim_color),
      axis.title.y.right = element_text(color = "#808080")
    )

  p
}

covidc <- function(county_state) {
  cnty_name <- str_trim(str_split_fixed(county_state, ",", n = 2)[1])
  state_name <- str_trim(str_split_fixed(county_state, ",", n = 2)[2])


  c <- get_cnty(cnty_name, state_name)

  # output stats
  print(str_glue("{cnty_name} County, {state_name} has ",
                 "{format(c$cases[nrow(c)], big.mark = ',')} cases ",
                 "({format(c$ncases[nrow(c)], big.mark = ',')} cases per day) and ",
                 "{format(c$deaths[nrow(c)], big.mark = ',')} deaths ",
                 "({format(c$ndeaths[nrow(c)], big.mark = ',')} deaths per day)."
        )
  )

  # display new cases and new deaths
  scale_d <- 20

  p <- ggplot(data = c, mapping = aes(x = date)) +
    #geom_point(
    #  aes(y = ndeaths * scale_d, color = prim_color),  # unclear why color reversal is required
    #  size = 0.8, na.rm = TRUE, alpha = 0.8
    #) +
    #geom_point(
    #  aes(y = ncases, color = "#808080"),  # unclear why color reversal is required
    #  size = 0.8, na.rm = TRUE, alpha = 1.0
    #) +
    #geom_smooth(
    #  aes(y = ndeaths * scale_d),
    #  se = FALSE,
    #  color = "#808080",
    #  method = "gam", formula = y ~ s(x, bs = "cs"), level = 0.9,
    #  na.rm = TRUE
    #) +
    #geom_smooth(
    #  aes(y = ncases),
    #  se = FALSE,
    #  color = "black",
    #  method = "gam", formula = y ~ s(x, bs = "cs"), level = 0.9,
    #  na.rm = TRUE
    #) +
    geom_line(
      aes(
        y = rollmean(
              ndeaths * scale_d,
              k = 7,
              fill = NA
            )
      ),
      color = "08080",
      size = 1,
      na.rm = TRUE
    ) +
    geom_line(
      aes(
        y = rollmean(
              ncases,
              k = 7,
              fill = NA
            )
      ),
      color = prim_color,
      size = 1,
      na.rm = TRUE
    ) +
    labs(
      subtitle = str_glue("{cnty_name} County, {state_name}"),
      x = "",
      y = "cases",
      color = "",
      caption = "(seven-day average)"
    ) +
    scale_x_date(limits = as.Date(c("2020-03-01",
                                    Sys.Date()
                                    ),
                                  origin = "1960-10-01"
                          )
    ) +
    scale_y_continuous(
      labels = scales::comma,
      sec.axis = sec_axis(~ . / scale_d,
                          name = "deaths",
                          labels = scales::comma
                 )
    ) +
    coord_cartesian(xlim = as.Date(c("2020-03-01",
                                     Sys.Date()
                                     ),
                                   origin = "1960-10-01"
                           )
    ) +
    scale_color_manual(
      labels = c("deaths", "cases"),
      values = c("#808080", prim_color),
      guide = "none"
    ) +
    theme(
      #axis.text.y = element_text(color = prim_color),
      axis.title.y = element_text(color = prim_color),
      #axis.text.y.right = element_text(color = "#808080"),
      axis.title.y.right = element_text(color = "#808080")
    )

  p
}

covid_total <- function(state_name = "United States") {
  if (state_name == "United States") {
    s <- us
  }
  else {
    s <- get_state(state_name)
  }

  # display new cases and new deaths
  scale_d <- 20

  p <- ggplot(data = s, mapping = aes(x = date)) +
    geom_area(
      aes(y = cases, fill = "#808080"),
      na.rm = TRUE,
      alpha = 0.8,
      color = "black"
    ) +
    geom_area(
      aes(y = deaths * scale_d, fill = prim_color),
      na.rm = TRUE,
      alpha = 0.8,
      color = "black"
    ) +
    labs(
      subtitle = state_name,
      x = "",
      y = "cases (cumulative)",
      fill = ""
    ) +
    scale_y_continuous(
      labels = scales::comma,
      sec.axis = sec_axis(~ . / scale_d,
                          name = "deaths (cumulative)",
                          labels = scales::comma
                 )
    ) +
    coord_cartesian(xlim = as.Date(c("2020-03-15",
                                     Sys.Date()
                                     ),
                                   origin = "1960-10-01"
                           ),
                    ylim = c(0, max(s$cases))
    ) +
    scale_fill_manual(
      labels = c("deaths", "cases"),
      values = c("#808080", prim_color),
      guide = "none"
    ) +
    theme(
      #axis.text.y = element_text(color = prim_color),
      axis.title.y = element_text(color = prim_color),
      #axis.text.y.right = element_text(color = "#808080"),
      axis.title.y.right = element_text(color = "#808080")
    )

  p
}

covidc_total <- function(county_state) {
  cnty_name <- str_trim(str_split_fixed(county_state, ",", n = 2)[1])
  state_name <- str_trim(str_split_fixed(county_state, ",", n = 2)[2])


  c <- get_cnty(cnty_name, state_name)

  # display new cases and new deaths
  scale_d <- 20

  p <- ggplot(data = c, mapping = aes(x = date)) +
   geom_area(
      aes(y = cases, fill = "#808080"),
      na.rm = TRUE,
      alpha = 0.8
    ) +
    geom_area(
      aes(y = deaths * scale_d, fill = prim_color),
      na.rm = TRUE,
      alpha = 0.9
    ) +
    labs(
      subtitle = str_glue("{cnty_name} County, {state_name}"),
      x = "",
      y = "cases (cumulative)",
      fill = ""
    ) +
    scale_x_date(limits = as.Date(c("2020-03-01",
                                    Sys.Date()
                                    ),
                                  origin = "1960-10-01"
                          )
    ) +
    scale_y_continuous(
      labels = scales::comma,
      sec.axis = sec_axis(~ . / scale_d,
                          name = "deaths (cumulative)",
                          labels = scales::comma
                 )
    ) +
    coord_cartesian(xlim = as.Date(c("2020-03-01",
                                     Sys.Date()
                                     ),
                                   origin = "1960-10-01"
                           ),
                    ylim = c(0, max(c$cases))
    ) +
    scale_fill_manual(
      labels = c("deaths", "cases"),
      values = c("#808080", prim_color),
      guide = "none"
    ) +
    theme(
      #axis.text.y = element_text(color = prim_color),
      axis.title.y = element_text(color = prim_color),
      #axis.text.y.right = element_text(color = "#808080"),
      axis.title.y.right = element_text(color = "#808080")
    )

  p
}

calculate_risk_prediction_country <- function(country_name) {
  c <- get_country(country_name)

  # data to be used for fitting linear regression model
  reg_data <- top_n(c, 12, date)

  # linear regression model
  reg_model <- lsfit(reg_data$date, reg_data$ncases)

  return(reg_model$coefficients["X"]) # return slope of ncases rate
}
calculate_risk_prediction_country_c <- compiler::cmpfun(calculate_risk_prediction_country)

calculate_risk_prediction_state <- function(state_name) {
  s <- get_state(state_name)

  # data to be used for fitting linear regression model
  reg_data <- top_n(s, 12, date)

  # linear regression model
  reg_model <- lsfit(reg_data$date, reg_data$ncases)

  return(reg_model$coefficients["X"]) # return slope of ncases rate
}
calculate_risk_prediction_state_c <- compiler::cmpfun(calculate_risk_prediction_state)

calculate_risk_prediction_cnty <- function(cnty_name, state_name) {
  c <- get_cnty(cnty_name, state_name) # county object

  if (nrow(c) > 20) {
    # data to be used for fitting linear regression model
    reg_data <- top_n(c, 12, date)

    # linear regression model
    reg_model <- lsfit(reg_data$date, reg_data$ncases)

    return(reg_model$coefficients["X"]) # return slope of ncases rate
  }

  return(0)
}
calculate_risk_prediction_cnty_c <- compiler::cmpfun(calculate_risk_prediction_cnty)

```

```{r global, include = FALSE}

# enable parallel backend
doParallel::registerDoParallel()

# global analysis

global_risk_predictions <- global_cases %>% distinct(country)
global_risk_predictions <- global_risk_predictions %>%  # calculate risk prediction for each country
  mutate(
    risk_prediction = map_dbl(global_risk_predictions$country,
                            ~ calculate_risk_prediction_country_c(.)
                            )
  )

regions_join <- regions %>%
  mutate(country = recode(country,
                          "United States" = "US",
                          "Cape Verde" = "Cabo Verde",
                          "Congo, Dem. Rep." = "Congo (Brazzaville)",
                          "Congo, Rep." = "Congo (Kinshasa)",
                          "Czech Republic" = "Czechia",
                          "Taiwan" = "Taiwan*",
                          "São Tomé and Príncipe" = "Sao Tome and Principe",
                          "South Korea" = "Korea, South",
                          "Kyrgyz Republic" = "Kyrgyzstan",
                          "St. Lucia" = "Saint Lucia",
                          "St. Vincent and the Grenadines" = "Saint Vincent and the Grenadines",
                          "Slovak Republic" = "Slovakia",
                          "Lao" = "Laos"
                          )
  )

global_risk_predictions <- global_risk_predictions %>%
  left_join(regions_join, by = "country")

gdp_join <- gdp %>%  # match country names where different prior to join
  mutate(country = recode(country,
                          "Bahamas, The" = "Bahamas",
                          "People's Republic of China" = "China",
                          "United States" = "US",
                          "Cape Verde" = "Cabo Verde",
                          "Congo, Democratic Republic of the" = "Congo (Brazzaville)",
                          "Congo, Republic of the" = "Congo (Kinshasa)",
                          "Côte d'Ivoire" = "Cote d'Ivoire",
                          "Czech Republic" = "Czechia",
                          "Gambia, The" = "Gambia",
                          "Taiwan" = "Taiwan*",
                          "Myanmar" = "Burma",
                          "São Tomé and Príncipe" = "Sao Tome and Principe"
                          )
  )

global_predictions_gdp <- global_risk_predictions %>%
  left_join(gdp_join, by = "country") %>%
  filter(!is.na(gdp_ppp_pcap))

```

```{r us, include = FALSE}

# u.s. analysis

us <- us %>%
  mutate(
    ncases = cases - lag(cases, default = cases[1]),
    ndeaths = deaths - lag(deaths, default = deaths[1])
  )

p_us_total <- covid_total()
p_us <- covid()

```

```{r states, include = FALSE}

# state analysis (u.s.)

# calculate state risk predictions
state_risk_predictions <- state_df %>% distinct(state)
state_risk_predictions <- state_risk_predictions %>% # calculate risk prediction for each state
  mutate(
    risk_prediction = map_dbl(state_risk_predictions$state,
                            ~ calculate_risk_prediction_state_c(.)
                            )
  )

state_alarm_threshold <- 25
count_alarm_states <- sum(state_risk_predictions$risk_prediction >= state_alarm_threshold)

state_alarm_sorted_df <- state_risk_predictions %>% # highest risk predictions
  filter(risk_prediction > 5) %>%
  top_n( # return between 15 and 20 results - 15 if the alarm list is short, 20 if it is long
    max(
      c(
        min(
          c(count_alarm_states,20)
        )
        , 15
      )
    ),
    risk_prediction
  ) %>% 
  arrange(-risk_prediction)

```

```{r counties, include = FALSE}

# county analysis (u.s.)

# calculate county risk predictions
cnty_risk_predictions <- county_df %>%
  filter(county != "Unknown") %>%
  distinct(county, state, fips) %>%
  mutate(state = as.character(state), county = as.character(county))

cnty_risk_predictions <- cnty_risk_predictions %>% # add current risk predictions
  mutate(risk_prediction = map2_dbl(cnty_risk_predictions$county,
                              cnty_risk_predictions$state,
                              ~ calculate_risk_prediction_cnty_c(.x, .y)
                     )
  )

cnty_table <- cnty_risk_predictions %>% # highest risk predictions
  filter(risk_prediction > 5) %>%
  top_n(16, risk_prediction) %>%
  arrange(desc(risk_prediction)) %>%
  mutate(
    order = as.factor(row_number(risk_prediction)),
    county = as.factor(county),
    state = as.factor(state)
  )

```

<br><br>

---

# Summary Results

### World

```{r world_risk, out.width = "90%"}

global_risk_predictions %>%
  mutate(
    country = recode(
                country,
                "US" = "United States"
              )
  ) %>%
  top_n(15, risk_prediction) %>%
  ggplot(
    aes(
      x = risk_prediction,
      y = fct_reorder(
            country,
            risk_prediction
          )
    )
  ) +
    geom_col(
      width = 0.8,
      alpha = 0.8,
      color = "black",
      fill = prim_color
    ) +
    labs(
      subtitle = "Countries with Highest Predicted COVID-19 Risk",
      x = expression(rho),
      y = ""
    ) +
    scale_x_continuous(labels = scales::comma)

```

<br><br>

```{r, world_risk_gdp, out.width = "95%"}

global_predictions_gdp %>%
  mutate(
    country = recode(
                country,
                "US" = "United States"
              )
  ) %>%
  filter(risk_prediction > 25) %>%
  ggplot(aes(gdp_ppp_pcap, risk_prediction)) +
    geom_point(
      aes(
        fill = continent
      ),
      shape = 21,
      color = "black",
      alpha = 1.0,
      #size = 2.5
    ) +
    geom_text_repel(
      aes(label = country),
      point.padding = 0.1,
      segment.color = "grey"
    ) +
    labs(
      subtitle = "COVID-19 Risk Prediction vs GDP",
      x = "Gross Domestic Product (per capita)",
      y = expression(rho)
    ) +
    scale_x_continuous(
      labels = scales::dollar
    ) +
    scale_y_continuous(
      trans = "log10",
      labels = scales::comma
    ) +
    coord_cartesian(
      ylim = c(10, NA)
    ) +
    scale_color_brewer(palette = "Set1")

```

There are `r nrow(global_risk_predictions)` countries represented in the Johns Hopkins University data set. The Gross Domestic Product (GDP) data shown above represents per capita GDP at purchasing power parity (PPP) in [international (Geary-Khamis) dollars](https://en.wikipedia.org/wiki/International_dollar). These data are obtained from the [Countries by GDP (PPP) per capita](https://en.wikipedia.org/wiki/List_of_countries_by_GDP_(PPP)_per_capita) (Wikipedia) web page. Only countries with a risk prediction value above 25 are shown.

<br>

---

<br>

### U.S.

```{r country_summary, include = FALSE}

total_us_cases <- us_live$cases[nrow(us_live)]
current_us_ncases <- us$ncases[nrow(us)]
total_us_deaths <- us_live$deaths[nrow(us_live)]
current_us_ndeaths <- us$ndeaths[nrow(us)]

```

There have been `r format( total_us_cases, big.mark="," )` total COVID-19 cases (`r format( current_us_ncases, big.mark="," )` new cases per day) and `r format( total_us_deaths, big.mark="," )` deaths (`r format( current_us_ndeaths, big.mark="," )` new deaths per day) in the United States from `r format(min(us$date), '%B %d, %Y')` to `r format(max(us$date), '%B %d, %Y')`.

<br><br>

```{r country_chart_total, include = TRUE, out.width = "80%"}

p_us_total

```

<br><br>

```{r country_chart_change, out.width = "80%"}

p_us

```

<br><br>

```{r country_chart_hospitalizations, out.width = "80%"}

hosps %>%
  filter(
    entity == "United States"
  ) %>% 
  select(
    entity,
    date,
    "daily ICU occupancy" = `Daily ICU occupancy per million`,
    "daily hospital occupancy" = `Daily hospital occupancy per million`
  ) %>% 
  pivot_longer(
    cols = `daily ICU occupancy`:`daily hospital occupancy`,
    names_to = "category"
  ) %>% 
  ggplot(
    aes(x = date)
  ) +
    geom_line(
      aes(
        y = value,
        color = category
      ),
      size = 1
    ) +
    labs(
      subtitle = "U.S. COVID-19 Hospital Admissions",
      x = "",
      y = "Occupancy (per million people)"
    ) +
    theme(
      legend.position = "bottom"
    ) +
    scale_color_brewer(palette = "Set2")

```

<br><br>

### Comparison with the European Union

The aggregated data from Johns Hopkins University CSSE was used to calculate a combined case rate for the 27 member states of the European Union (EU). The combined data were used to compare the pandemic response in the EU with the response in the U.S. over time. The rise in infections in the EU preceded the rise in the U.S. For time comparison, the 2,500th case recorded in the EU occurred on March 2, 2020. The 2,500th case in the U.S. was recorded on March 14, 2020. This comparison is minimally useful, however, because the populations of the two regions differ (U.S. - 328,239,523; EU - 447,206,135) and there are a number of other factors (e.g., population density, health care systems, prevalence of comorbidities) that are not consistent between the two.

<br>

```{r us_eu_comparison, include = TRUE, out.width = "80%"}

eu_color <- "#ff9000"

us %>%
  ggplot(mapping = aes(x = date)) +
    # European Union
    #geom_smooth(
    #  data = eu_combined_cases,
    #  aes(date, ncases),
    #  se = FALSE,
    #  color = eu_color,
    #  method = "gam", formula = y ~ s(x, bs = "cs"), level = 0.9,
    #  size = 0.8,
    #  na.rm = TRUE,
    #  show.legend = FALSE
    #) +
    #geom_point(
    #  data = eu_combined_cases,
    #  aes(date, ncases),
    #  color = eu_color,
    #  size = 0.8,
    #  alpha = 1.0,
    #  na.rm = TRUE,
    #  show.legend = FALSE
    #) +
    geom_line(
      data = eu_combined_cases,
      aes(
        y = rollmean(
              ncases,
              k = 7,
              fill = NA
            )
      ),
      color = eu_color,
      size = 1,
      na.rm = TRUE
    ) +
    annotate(
      geom = "text",
      label = "European Union",
      x = as.Date("2020-12-16"),
      y = 20000,
      color = eu_color,
      size = 4.5
    ) +
    # United States
    #geom_smooth(
    #  aes(y = ncases),
    #  se = FALSE,
    #  color = prim_color,
    #  method = "gam", formula = y ~ s(x, bs = "cs"), level = 0.9,
    #  size = 1.2,
    #  na.rm = TRUE,
    #  show.legend = FALSE
    #) +
    #geom_point(
    #  aes(y = ncases, color = prim_color),
    #  color = prim_color,
    #  size = 0.8,
    #  alpha = 1.0,
    #  na.rm = TRUE,
    #  show.legend = FALSE
    #) +
    geom_line(
      aes(
        y = rollmean(
              ncases,
              k = 7,
              fill = NA
            )
      ),
      color = prim_color,
      size = 1,
      na.rm = TRUE
    ) +
    annotate(
      geom = "text",
      label = "United States",
      x = as.Date("2020-06-08"),
      y = 120000,
      color = prim_color,
      size = 4.5
    ) +
    labs(
      subtitle = "COVID-19 Daily Case Rates:  US and EU",
      x = "",
      y = "cases",
      color = "",
      caption = "(seven-day average)"
    ) +
    scale_y_continuous(
      labels = scales::comma
    ) +
    coord_cartesian(xlim = as.Date(c("2020-03-01",
                                     Sys.Date()
                                     ),
                                   origin = "1960-10-01"
                           ),
                    ylim = c(0, NA)
    )

```

<br>

---

<br>

### Individual States

```{r state_predictions, out.width = "90%"}

state_alarm_sorted_df %>%
  ggplot(
    aes(
      x = reorder(state, risk_prediction),
      y = risk_prediction
    )
  ) +
    geom_hline(yintercept = state_alarm_threshold,
               size = 0.5,
               color = "darkgrey",
               linetype = "dotted"
    ) +
    geom_bar(
      aes(
        fill = risk_prediction < state_alarm_threshold
      ),
      stat = "identity",
      width = 0.8,
      alpha = 0.8,
      color = "black",
      show.legend = FALSE
    ) +
    scale_y_continuous(labels = scales::comma) +
    coord_flip() +
    labs(
      subtitle = "States with Highest Predicted Risk",
      x = "",
      y = expression(rho),
      fill = ""
    ) +
    scale_fill_manual(values = c(prim_color, alt_color))

```

`r count_alarm_states` of `r length(state_risk_predictions$state)` states currently have risk predictions above 25. (Note: The state definition used here includes the District of Columbia, Puerto Rico, Virgin Islands, American Samoa, Guam, and Northern Mariana Islands.)

```{r state_charts, include = FALSE}

#p1 <- covid(state_alarm_sorted_df$state[1])
#p2 <- covid(state_alarm_sorted_df$state[2])
#p3 <- covid(state_alarm_sorted_df$state[3])
#p4 <- covid(state_alarm_sorted_df$state[4])
#p5 <- covid(state_alarm_sorted_df$state[5])
#p6 <- covid(state_alarm_sorted_df$state[6])

p1 <- covid("California")
p2 <- covid("Texas")
p3 <- covid("New York")
p4 <- covid("Florida")
p5 <- covid("Georgia")
p6 <- covid("Oregon")

```

<br><br>

```{r disp_state_charts, fig.asp=1.13}

grid.arrange(p1, p2, p3, p4, p5, p6, ncol = 2)

```

<br>

---

<br>

### Counties

```{r county_predictions}

base_palette_len <- 10
get_palette <- colorRampPalette(pal_jco()(base_palette_len))

n_states <- n_distinct(cnty_table$state)
palette_len <- ifelse(n_states > base_palette_len, n_states, base_palette_len)

cnty_table %>%
  mutate(county = fct_reorder(county, risk_prediction)) %>%
  ggplot(aes(x = order, y = risk_prediction)) +
    geom_bar(
      aes(fill = fct_reorder2(state, county, risk_prediction)),
      stat = "identity",
      width = 0.8,
      alpha = 0.8,
      color = "black"
    ) +
    scale_x_discrete(labels = rev(cnty_table$county)) +
    scale_fill_manual(values = get_palette(palette_len)) +
    labs(
      subtitle = "Counties with Highest Predicted Risk",
      x = "",
      y = expression(rho),
      fill = "state"
    ) +
    scale_y_continuous(labels = scales::comma) +
    coord_flip()

```

There are `r format(nrow(cnty_risk_predictions), big.mark = ",")` U.S. counties represented in the New York Times data set.

<br>

---

<br>

### Deaths

```{r state_deaths, out.width = "80%"}

state_deaths_df <- state_df %>% 
  group_by(state) %>% 
  summarise(
    deaths = max(deaths),
    .groups = "drop"
  ) %>% 
  left_join( # join with state population library dataframe
    state_populations_2018,
    by = c("state" = "state")
  ) %>% 
  filter(
    !is.na(population),
    !is.na(region)
  ) %>% 
  select(
    state,
    deaths,
    population,
    region
  ) %>%
  mutate(
    population = population,
    death_rate = deaths / population,
    region = fct_relevel(region, c("West", "Midwest", "South", "Northeast")),
    deaths_per_million = death_rate * 1e6,
    population_millions = population / 1e6
  )

state_labels <- state_deaths_df %>% 
  filter(
    state %in% c(
      "New York",
      "Texas",
      "California",
      "Vermont",
      "Maine",
      "Arizona",
      "Mississippi",
      "New Jersey",
      "Michagin",
      "Alabama",
      "Hawaii",
      "Utah",
      "Wyoming"
    )
  )

state_deaths_df %>% 
  ggplot(
    aes(
      x = population_millions,
      y = deaths
    )
  ) +
    geom_point(
      shape = 21,
      fill = prim_color,
      color = "black",
      size = 2.5,
      alpha = 0.8
    ) +
    geom_text_repel(
      data = state_labels,
      aes(label = state),
      min.segment.length = 0,
      #point.padding = 5.0,
      segment.color = "grey",
      size = 4
    ) +
    scale_x_continuous(
      trans = "log10"
    ) +
    scale_y_continuous(
      trans = "log10",
      labels = scales::comma
    ) +
    labs(
      subtitle = "COVID-19 Deaths by State",
      x = "population (log – in millions)",
      y = "deaths (log)"
    ) +
    scale_fill_nejm()

```

<br><br>

```{r state_death_rates}
state_deaths_df %>% 
  filter(
    !is.na(region)
  ) %>% 
  mutate(
    deaths_per_million = death_rate * 1e6,
    population_millions = population / 1e6
  ) %>% 
  ggplot(
    aes(
      x = population_millions,
      y = deaths_per_million
    )
  ) +
    geom_point(
      aes(
        fill = region,
        size = deaths
      ),
      shape = 21,
      color = "black",
      alpha = 0.8
    ) +
    geom_text_repel(
      aes(label = state),
      point.padding = 0.2,
      segment.color = "grey",
      size = 3
    ) +
    facet_wrap(
      vars(region),
      ncol = 2
    ) +
    scale_x_continuous(
      trans = "log10"
    ) +
    scale_y_continuous(
      labels = scales::comma
    ) +
    labs(
      subtitle = "COVID-19 Death Rates by State and by Region",
      x = "population (log – in millions)",
      y = "deaths (per million people)"
    ) +
    scale_fill_nejm()

```

<br>

---

<br>

```{r region_death_rates_one, out.width = "80%"}

region_deaths_df <- state_df %>% 
  group_by(state) %>% 
  summarise(
    state_deaths = max(deaths),
    .groups = "drop"
  ) %>% 
  left_join( # join with state population library dataframe
    state_populations_2018,
    by = c("state" = "state")
  ) %>% 
  filter(
    !is.na(population)
  ) %>% 
  select(
    state,
    state_deaths,
    population,
    region
  ) %>%
  group_by(region) %>% 
  summarise(
    deaths = sum(state_deaths),
    population = sum(population),
    .groups = "drop"
  ) %>% 
  mutate(
    death_rate = deaths / population,
    region = fct_relevel(region, c("West", "Midwest", "South", "Northeast")),
  )

```

```{r region_death_rates_two, out.width = "80%"}
# plot deaths (total)
region_deaths_df %>% 
  filter(
    !is.na(region)
  ) %>% 
  mutate(
    deaths_per_million = death_rate * 1e6,
    population_millions = population / 1e6
  ) %>% 
  select(
    region,
    deaths,
    deaths_per_million
  ) %>% 
  ggplot(
    aes(
      x = region,
      y = deaths
    )
  ) +
    geom_col(
      aes(
        fill = region,
      ),
      color = "black",
      #show.legend = FALSE,
      width = 0.8,
      alpha = 0.8
    ) +
    scale_y_continuous(
      labels = scales::comma
    ) +
    labs(
      subtitle = "COVID-19 Total Deaths by Region",
      x = "",
      y = "deaths"
    ) +
    scale_fill_nejm()

```

```{r region_death_rates_three, out.width = "80%", include = FALSE}
# plot deaths
region_deaths_df %>% 
  filter(
    !is.na(region)
  ) %>% 
  mutate(
    deaths_per_million = death_rate * 1e6,
    population_millions = population / 1e6
  ) %>% 
  select(
    region,
    deaths,
    deaths_per_million
  ) %>% 
  ggplot(
    aes(
      x = region,
      y = deaths_per_million
    )
  ) +
    geom_col(
      aes(
        fill = region,
      ),
      color = "black",
      #show.legend = FALSE,
      width = 0.8,
      alpha = 0.8
    ) +
    scale_y_continuous(
      labels = scales::comma
    ) +
    labs(
      subtitle = "COVID-19 Death Rates by Region",
      x = "",
      y = "deaths (per million people)"
    ) +
    scale_fill_nejm()

```

<br>

```{r region_death_rates_boxplot, out.width = "80%"}

state_df %>% 
  group_by(state) %>% 
  summarise(
    state_deaths = max(deaths),
    .groups = "drop"
  ) %>% 
  left_join( # join with state population library dataframe
    state_populations_2018,
    by = c("state" = "state")
  ) %>% 
  select(
    state,
    state_deaths,
    population,
    region
  ) %>%
  filter(
    !is.na(population),
    !is.na(region)
  ) %>% 
  mutate(
    death_rate_per_million = state_deaths / population * 1e6
  ) %>% 
  group_by(region) %>% 
  ggplot(
    aes(
      x = fct_relevel(region, c("West", "Midwest", "South", "Northeast")),
      y = death_rate_per_million
    )
  ) +
    geom_boxplot(
      aes(
        fill = region
      ),
      alpha = 0.8,
    ) +
    geom_jitter(
      color = "black",
      width = 0.02
    ) +
    #geom_point(
    #  data = region_deaths_df,
    #  aes(
    #    #x = fct_relevel(region, c("West", "Midwest", "South", "Northeast")),
    #    #x = region,
    #    y = death_rate * 1e6
    #  ),
    #  shape = 21,
    #  fill = "black",
    #  color = "black",
    #  size = 6
    #) +
    labs(
      subtitle = "COVID-19 Death Rates by Region (box plot)",
      x = "",
      y = "deaths (per million people)"
    ) +
    scale_y_continuous(
      labels = scales::comma
    ) +
    scale_fill_nejm()

```

<br><br><br>

---

<br>

# Community Mobility Data

For the purpose of assisting the global COVID-19 pandemic response, Google has made available detailed mobility estimates relative to local baselines obtained from mobile phone and other data of the type used by traffic, etc., services like Google Maps and Waze. The data are provided by Google in the form of [Community Mobility Reports](https://www.google.com/covid19/mobility/).

>As global communities respond to COVID-19, we've heard from public health officials that the same type of aggregated, anonymized insights we use in products such as Google Maps could be helpful as they make critical decisions to combat COVID-19.
>
>These Community Mobility Reports aim to provide insights into what has changed in response to policies aimed at combating COVID-19. The reports chart movement trends over time by geography, across different categories of places such as retail and recreation, groceries and pharmacies, parks, transit stations, workplaces, and residential.

```{r mobility_import, include = FALSE}

#community_mobility <- readr::read_csv("./global-mobility-data/Global_Mobility_Report.csv", guess_max = 1e6)  # global mobility data
community_mobility <- readr::read_csv("https://www.gstatic.com/covid19/mobility/Global_Mobility_Report.csv", guess_max = 1e6)  # global mobility data

community_mobility <- community_mobility %>%
  mutate(date = as.Date(date))

```

The data used for the analysis below is current through `r format(max(community_mobility$date), '%B %d, %Y')`.

<br>

```{r community_mobility}

df_highlights <- community_mobility %>%
  filter(
    is.na(sub_region_1),
    is.na(sub_region_2),
    country_region %in% c(
                          "United States",
                          "Italy",
                          "Spain",
                          "United Kingdom",
                          "France",
                          "Sweden",
                          "Ireland"
                        )
  ) %>%
  rename(country = country_region)

p <- community_mobility %>%
  left_join(regions, by = c("country_region" = "country")) %>%
  filter(
    is.na(sub_region_1),
    is.na(sub_region_2),
    country_region %in% c(eu_countries$Country, "Czechia")
  ) %>%
  rename(country = country_region) %>%
  ggplot(aes(date, retail_and_recreation_percent_change_from_baseline, group = country)) +
    geom_hline(
      yintercept = 0,
      color = "grey",
    ) +
    geom_smooth(
      color = "#dddddd",
      se = FALSE,
      method = "gam", formula = y ~ s(x, bs = "cs"), level = 0.9,
      size = 0.5
    ) +
    geom_smooth(
      data = df_highlights,
      aes(
        date, retail_and_recreation_percent_change_from_baseline,
        color = fct_reorder(country, desc(retail_and_recreation_percent_change_from_baseline))
      ),
      se = FALSE,
      method = "gam", formula = y ~ s(x, bs = "cs"), level = 0.9,
      size = 1.2
    ) +
    scale_y_continuous(labels = scales::label_percent(scale = 1)) +
    labs(
      title = "Community Mobility: US and EU",
      subtitle = "retail and recreation",
      x = "",
      y = "change from baseline",
      color = "country"
    ) +
    scale_color_jco()

#plotly::ggplotly(p, tooltip = "country")
p

```

---

<br>

### U.S.

<br>

```{r us_mobility}

# United States
us_mobility <- community_mobility %>%  # u.s. mobility data
  filter(
    country_region_code == "US"
  ) %>%
  rename(
    country = country_region,  # country
    state = sub_region_1,  # state
    cnty = sub_region_2  # county
  ) %>%
  select(
    -country_region_code,
    -(iso_3166_2_code:census_fips_code)
  )

us_mobility_pivot <- us_mobility %>%
  setNames(gsub("_percent_change_from_baseline", "", names(.))) %>%
  pivot_longer(cols = retail_and_recreation:residential, names_to = "activity_category", values_to = "change_from_baseline")


us_mobility_pivot %>%
  filter(
    is.na(state),
    is.na(cnty),
    activity_category %in% c(
                             "retail_and_recreation",
                             "parks",
                             "residential",
                             "transit_stations"
                             )
  ) %>%  # u.s. country-level data
  ded_recode(
    activity_category,
    "retail and recreation=retail_and_recreation",
    "transit stations=transit_stations"
  ) %>%
  ggplot(aes(date, change_from_baseline, group = activity_category)) +
    geom_hline(
      yintercept = 0,
      color = "grey",
    ) +
    geom_vline(
      xintercept = as.Date("2020-03-13"),
      color = "grey",
      size = 1,
      linetype = "dotted"
    ) + # u.s. declares national emergency
    geom_smooth(
      aes(color = activity_category),
      se = FALSE,
      method = "gam", formula = y ~ s(x, bs = "cs"), level = 0.9,
      size = 1.2
    ) +
    coord_cartesian(
      xlim = as.Date(c("2020-03-13", NA))
    ) +
    scale_y_continuous(labels = scales::label_percent(scale = 1)) +
    annotate(
      geom = "text",
      label = "U.S. national emergency declared on March 13, 2020",
      angle = 90,
      x = as.Date("2020-02-27"),
      y = 36,
      color = "black",
      size = 2.5
    ) +
    labs(
      title = "Community Mobility - United States",
      x = "", y = "change from baseline",
      color = "activity"
    ) +
    scale_color_jco()

```

**Note:**  The dotted grey line on each of the mobility charts represents the date (March 13, 2020) on which the U.S. declared a [National Emergency Concerning the Novel Coronavirus Disease (COVID-19) Outbreak](https://www.whitehouse.gov/presidential-actions/proclamation-declaring-national-emergency-concerning-novel-coronavirus-disease-covid-19-outbreak/).

<br>

---

<br>

### Individual States

<br>

```{r state_mobility}

us_mobility_pivot %>%
  filter(
    is.na(cnty),
    activity_category %in% c(
                             "retail_and_recreation",
                             "transit_stations"
                             ),
    state %in% c(
                 "California",
                 "Texas",
                 "Arizona",
                 "Florida",
                 "Oklahoma",
                 "South Carolina",
                 "New York",
                 "District of Columbia"
                 )
  ) %>%
  ded_recode(
    activity_category,
    "retail and recreation=retail_and_recreation",
    "transit stations=transit_stations"
  ) %>%
  ggplot(aes(date, change_from_baseline, color = state)) +
    geom_hline(
      yintercept = 0,
      color = "grey",
    ) +
    geom_vline(
      xintercept = as.Date("2020-03-13"),
      color = "grey",
      size = 1,
      linetype = "dotted"
    ) + # u.s. declares national emergency
    geom_smooth(
      se = FALSE,
      method = "gam", formula = y ~ s(x, bs = "cs"), level = 0.9,
      size = 1.2
    ) +
    coord_cartesian(
      xlim = as.Date(c("2020-03-13", NA)),
      ylim = c(-75, 20)
    ) +
    facet_grid(. ~ activity_category) +
    labs(
      title = "Community Mobility - States",
      x = "", y = "change from baseline (%)",
      color = "state"
    ) +
    scale_color_jco()

```
